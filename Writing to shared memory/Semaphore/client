/*
Sarah Chow
Client, send data to shared memory

Open and post the file and new data pointers at beginning and while loop to constantly update

*/

#include <iostream>
#include <pthread.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <ctime>
#include <sys/types.h>
#include <sys/stat.h>
#include <semaphore.h>

#include <errno.h>

#define SIZE 256
#define SEM_NAME "/semTest" // Same name to share semaphores
#define SEM_NEWDATA "/signal-new-data" // Semaphore to signal to writer there is new data
#define FILENAME "/testSHM"

// Need to add a safe if input exceeds size

struct memory_data
{
    char input[SIZE];
};

std::ostream &operator<<(std::ostream &os, struct tm const *ltime)
{
    return os << ltime->tm_sec;
} // Override insertion operator

int main()
{
    int fileDir, trunResult;
    bool run = true;

    char buffer[SIZE];

    size_t sizeTime, sizeBuf;
    //const char *fileName = "/testSHM"; // Pointing to where /testSHM is in memory

    time_t my_time;
    char *outputTime = nullptr;
    struct tm *ltime; // Local time

    struct memory_data *addr;

    sem_t *semPtr, *semNewData;

    if ((semPtr = sem_open(SEM_NAME, O_CREAT, 0700, 0)) == SEM_FAILED) // Access semaphore
    {
        std::cout << "sem open failed\n";
        std::cout << errno << std::endl;
        return (1);
    }

    if ((semNewData = sem_open(SEM_NEWDATA, O_CREAT, 0700, 0)) == SEM_FAILED) 
    {
        std::cout << "sem new data failed\n";
        return (1);
    }


    if ((fileDir = shm_open(FILENAME, O_CREAT | O_RDWR, 0666)) == -1) // Read, write by owner, group
    {
        std::cout << "file opening error";
        exit(1);
    } // Open and create a file if it does not already exist

    if ((ftruncate(fileDir, sizeof(struct memory_data))) == -1)
    {
        std::cout << "truncate fail\n";
        return (1);
    }
//ftruncate needed?

    if ((addr = (struct memory_data *)mmap(NULL, sizeof(struct memory_data), PROT_READ | PROT_WRITE, MAP_SHARED, fileDir, 0)) == MAP_FAILED)
    {
        std::cout << "mmap failed\n" << std::endl;
        return (1);
    }



    while (run)
    {

// Why wait on this?
        if ((sem_wait(semPtr)) == -1) // Interruptable, blocks file semaphore
        {
            std::cout << "sem wait failed\n";
            return (1);
        }



        fgets(buffer, sizeof(buffer), stdin);

        sizeBuf = strlen(buffer);


        if ((buffer[sizeBuf - 1] == '\n') && (sizeBuf == 1)) // Exit loop when user enters blank space (for now)
        {
            run = false;
        }
        else // Keep loop going
        {

            if (buffer[sizeBuf - 1] == '\n')
            {
                buffer[sizeBuf - 1] = '\0'; // Rid of newline
            }

            // Reset the time
            time(&my_time);              // Current time put into my_time
            ltime = localtime(&my_time); // Return the 'struct tm' representation of timer in local time zone

            outputTime = asctime(ltime); // Takes in a pointer, converts to string
            //std::cout << ltime;

            strcpy(addr->input, buffer);
            // Make a copy of input and place in input




            if ((sem_post(semNewData)) == -1) // Signal new information, unblock
            {
                std::cout << "sem post new data failure loop\n";
                return(1);
            }


            if ((sem_post(semPtr)) == -1) // Unblock semaphore
            {
                std::cout << "sem post failure loop\n";
                return(1);
            }

        }
    }


    if (munmap(addr, sizeof(struct memory_data)) == -1)
    {
        std::cout << "munmap failed\n";
        return (1);
    }


    close(fileDir);

    shm_unlink("/testSHM");

    sem_unlink(SEM_NAME);
    sem_unlink(SEM_NEWDATA);

    return (0);
}
