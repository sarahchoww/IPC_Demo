/*
Sarah Chow
Server, take data from shared memory and writes to file.

Open and post only at the beginning to acknowledge the client
Open and post the new data semaphore to signify new data has come in

Currently adds to the hexdump.
*/

#include <iostream>
#include <pthread.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <ctime>
#include <sys/types.h>
#include <sys/stat.h>
#include <semaphore.h>

#include <errno.h>

#define SIZE 256
#define SEM_NAME "/semTest" // Same name to share semaphores
#define SEM_NEWDATA "/signal-new-data"
#define FILENAME "/testSHM"

// Need to add a safe if input exceeds size

struct memory_data
{
    char input[SIZE];
};

std::ostream &operator<<(std::ostream &os, struct tm const *ltime)
{
    return os << ltime->tm_sec;
} // Override insertion operator

int main()
{
    int fileDir;

    char buffer[SIZE];

    size_t sizeTime, sizeBuf;
    //const char *fileName = "/testSHM"; // Pointing to where /testSHM is in memory

    time_t my_time;
    char *outputTime = nullptr;
    struct tm *ltime; // Local time

    struct memory_data *addr;
    // Set size of addr

    sem_t *semPtr, *semNewData;

    if ((semPtr = sem_open(SEM_NAME, O_CREAT, 0700, 0)) == SEM_FAILED) // Access the semaphore
    {
        std::cout << "sem open failed\n";
        return (1);
    }

    if ((semNewData = sem_open(SEM_NEWDATA, O_CREAT, 0700, 0)) == SEM_FAILED)
    {
        std::cout << "sem new data failed\n";
        return (1);
    }

    if ((fileDir = shm_open(FILENAME, O_CREAT | O_RDWR | O_APPEND, 0666)) == -1) // Open and create a file if it does not already exist
    {
        std::cout << "file opening error\n"
                  << errno;
        exit(1);
    }

    if ((ftruncate(fileDir, sizeof(struct memory_data))) == -1)
    {
        std::cout << "truncate fail\n";
        return (1);
    }

    
    if ((addr = (struct memory_data *)mmap(NULL, sizeof(struct memory_data), PROT_READ | PROT_WRITE, MAP_SHARED, fileDir, 0)) == MAP_FAILED)
    {
        std::cout << "mmap failed\n";
        return (1);
    }


    if ((sem_post(semPtr)) == -1) // Unblocks sem for client to acknowledge
    {
        std::cout << "sem post failed\n";
        return (1);
    }




    while (true)
    {

        strcpy(buffer, addr->input); // Copy contents of shared memory to buffer variable


        sizeBuf = strlen(buffer);

        if ((write(fileDir, buffer, sizeBuf)) == -1) // Offset of 0 - useful for watch hd <file>
        {
            std::cout << "write failure\n";
            return (1);
        }

        memset(addr->input, 0, sizeof(char) * SIZE);


// Put sem_wait at bottom, if client is run before server the output will be off
        if ((sem_wait(semNewData)) == -1) // Wait for signal, interruptable, blocks
        {
            std::cout << "sem wait new data failure\n";
            return (1);
        }



    }

    if (munmap(addr, sizeof(struct memory_data)) == -1)
    {
        std::cout << "munmap failed\n";
        return (1);
    }


    close(fileDir);

    shm_unlink("/testSHM");

    sem_unlink(SEM_NAME);
    sem_unlink(SEM_NEWDATA);

    //have safes for each of the terminations

    return (0);
}
